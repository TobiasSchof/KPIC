#!/usr/bin/env kpython3

#inherent python libraries
from configparser import ConfigParser
from atexit import register, unregister
from time import time, ctime, sleep
from signal import signal, SIGHUP, SIGTERM
from subprocess import Popen
from argparse import ArgumentParser
import sys, io, os, threading, logging

#installs
import FliSdk as cam
import numpy as np
import posix_ipc

#nfiuserver libraries
from shmlib import shm
from NPS_cmds import NPS_cmds

"""

THIS IS A CONTROL SCRIPT FOR THE FIBER INJECTION UNIT'S CRED2
AND NOT FOR USE BY USER

"""

#This script is not an import
if __name__ != "__main__": 
    print("TrackCam_Control is not meant to be used as an import.")
    sys.exit()

info=logging.info

class NPSError(Exception):
    """An exception to be thrown if there is an error with the NPS"""
    pass

class AlreadyAlive(Exception):
    """An exception to be thrown if control code is initialized twice"""
    pass

def listener():
    """A method to listen to command shared memory and perform requests"""

    while True:
        # get update counts of last read
        temp_cnt = Temp.mtdata["cnt0"]
        crop_cnt = Crop.mtdata["cnt0"]
        ndr_cnt = NDR.mtdata["cnt0"]
        exp_cnt = Exp.mtdata["cnt0"]

        # wait for one of the P shms to be updated
        ShmP.acquire()

        # use the counts stored previously to determine what has been updated
        if temp_cnt != Temp.get_counter():
            # set snake (sensor) temp
            cam.SetTempSnakeSetpoint(Temp.get_data()[0])
        if ndr_cnt != NDR.get_counter():
            # set non-destructive reads
            cam.
        if exp_cnt != Exp.get_counter():
            # set exposure time
            cam.SetTint(Exp.get_data()[0])
        if crop_cnt != Crop.get_counter():
            # set crop dimensions
            dim = Crop.get_data()
            cam.SetImageDimension(dim[0], dim[1])

RELDIR = os.environ.get("RELDIR")
if RELDIR[-1] == "/": RELDIR = RELDIR[:-1]

#read config file
config = ConfigParser()
config.read(RELDIR+"/data/TrackCam.ini")

log_path=config.get("Communication", "debug_log")
dbg_fmt = "%(filename)s.%(funcName)s@%(asctime)s - %(levelname)s: %(message)s"

parser = ArgumentParser()
#boolean flag for CAN_MOVE
parser.add_argument("-m", action="store_true")
#flags to put into debug mode
parser.add_argument("-d", default=-1, nargs="?")
parser.add_argument("-d!", "--dd", default=-1, nargs="?")

args = parser.parse_args()

CAN_MOVE = args.m #whether this device can move on startup

if args.dd != -1:
    if not args.dd is None: log_path=args.dd
    logging.basicConfig(format=dbg_fmt, datefmt="%H:%M:%S",\
        filename=log_path)
    logging.root.setLevel(logging.DEBUG)
elif args.d != -1:
    if not args.d is None: log_path=args.d
    logging.basicConfig(format=dbg_fmt, datefmt="%H:%M:%S", \
        filename=log_path)
    logging.root.setLevel(logging.INFO)

#make the folder for shared memories if it doesn't already exist
if not os.path.isdir("/tmp/TrackCam"): os.mkdir("/tmp/TrackCam")

#create a dictionary to translate strings into numpy data types
type_ = {"int8":np.int8, "int16":np.int16, "int32":np.int32, "int64":np.int64,
    "uint8":np.uint8, "uint16":np.uint16, "uint32":np.uint32,
    "uint64":np.uint64, "intp":np.intp, "uintp":np.uintp, "float16":np.float16,
    "float32":np.float32, "float64":np.float64, "complex64":np.complex64,
    "complex128":np.complex128}

# check to make sure there is no other control script alive
Temp = config.get("Shm_Info", "Temp_P").split(",")
if os.path.isfile(Temp[0]): raise AlreadyAlive("There is already an instance"+\
    " of this control script running.")

info("No duplicate control script, continuing with initialization.")

Error = config.get("Shm_Info", "Error").split(",")
if os.path.isfile(Error[0]): Error = shm(Error[0])
else:
    info("No state shared memory file. Creating file.")
    Error = config.get("Shm_Info", "Error").split(",") +\
        config.get("Shm_Init", "Error").split(",")
    Error = shm(Error[0], data=np.array([Error[2:]], dtype=type_[Error[1]]))

#NOTE: we want to register cleanup after Shm_D is initalized so we can edit it
#register handles keyboard interrupts and exceptions
#signal handles tmux kill-ses, and terminate
info("Registering cleanup.")
register(close)
signal(SIGHUP, close)
signal(SIGTERM, close)

info("Initializing command shared memory from config file.")

#create a subscription semaphore to link all P shms
ShmP = posix_ipc.Semaphore(None, flags = posix_ipc.O_CREX)

#create a list to store processes that are updating semaphores (to be killed 
#   at close)
Sem_Listeners = []

Temp = config.get("Shm_Info", "Temp_P").split(",") +\
    config.get("Shm_Init", "Temp_P").split(",")
Temp = shm(Temp[0], data=np.array([Temp[2:]], dtype=type_[Temp[1]]),\
     sem=True)
Sem_Listeners.append(Popen(["linksem", Temp.sem.name, ShmP.name]))

Crop = config.get("Shm_Info", "Crop").split(",") +\
    config.get("Shm_Init", "Crop").split(",")
Crop = shm(Crop[0], data=np.array([Crop[2:]], dtype=type_[Crop[1]]),\
    sem=True)
Sem_Listeners.append(Popen(["linksem", Crop.sem.name, ShmP.name]))

NDR = config.get("Shm_Info", "NDR_P").split(",") +\
    config.get("Shm_Init", "NDR_P").split(",")
NDR = shm(NDR[0], data=np.array([NDR[2:]], dtype=type_[NDR[1]]), sem=True)
Sem_Listeners.append(Popen(["linksem", NDR.sem.name, ShmP.name]))

Exp = config.get("Shm_Info", "Exposure_P").split(",") +\
    config.get("Shm_Init", "Exposure_P").split(",")
Exp = shm(Exp[0], data=np.array([Exp[2:]], dtype=type_[Exp[1]]), sem=True)
Sem_Listeners.append(Popen(["linksem", Exp.sem.name, ShmP.name]))

def Punlink():
    """Tries to unlink the lock semaphores on the P shms"""

    try: 
        Temp.lock.unlink()
    except (AttributeError, posix_ipc.ExistentialError) as ouch:
        info("Exception on close: {}".format(ouch))

    try: 
        Crop.lock.unlink()
    except (AttributeError, posix_ipc.ExistentialError) as ouch:
        info("Exception on close: {}".format(ouch))

    try: 
        NDR.lock.unlink()
    except (AttributeError, posix_ipc.ExistentialError) as ouch:
        info("Exception on close: {}".format(ouch))

    try: 
        Exp.lock.unlink()
    except (AttributeError, posix_ipc.ExistentialError) as ouch:
        info("Exception on close: {}".format(ouch))

#we want to register P shm unlink acter creating shared memory, otherwise
#  the shm will be cleaned up and we lose access to the lock
register(Punlink)
signal(SIGHUP, Punlink)
signal(SIGTERM, Punlink)

info("Command shared memories successfully created.")

info("Initializing NPS")
NPS=NPS_cmds()
info("Finding CRED2 port")
NPS.dev_port = None
for port in NPS.devices:
    if NPS.devices[port] == "Tracking Camera":
        NPS.dev_port = port
        break
if NPS.dev_port is None:
    info("Cannot find NPS port")
    raise NPSError("Cannot find NPS port")

#convenience methods to deal with the NPS
turn_on = lambda: NPS.turnOn(NPS.dev_port)
turn_off = lambda: NPS.turnOff(NPS.dev_port)
q_pow = lambda: NPS.getStatusAll()[NPS.dev_port]

#if the device is already on, connect to it
if q_pow(): connect_device()

info("Starting image puller")
cmd = "ImgPuller"
pull_proc = Popen(cmd.split(" "))
    
info("Starting display drawer")        
#we use popen to start the drawing script separately to prevent blocking
cmd = "TrackCam_draw"
draw_proc=Popen(cmd.split(" "))

listener()
