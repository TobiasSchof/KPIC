#!/usr/bin/env kpython3

#inherent python libraries
from subprocess import Popen as bash
from logging import info, basicConfig, INFO, DEBUG
from signal import signal, SIGHUP
from atexit import register 
from configparser import ConfigParser
from argparse import ArgumentParser
from time import time, ctime, sleep
import sys, os

#installs
from pipython import GCSDevice
import numpy as np

#telescope libraries
sys.path.insert(1, "/kroot/src/kss/nirspec/nsfiu/lib")

from sce_shmlib import shm
from NPS_lib import NPS

"""

THIS IS A CONTROL SCRIPT FOR THE TRACKING CAMER PICKOFF
NOT FOR USE BY USER

See TCP_cmds.py or type TCP in terminal to control the TCP

"""

config_path="/kroot/src/kss/nirspec/nsfiu/config/"

class AlreadyAlive(Exception):
    """An exception to be thrown if control code is initialized twice"""
    pass

class TCP:
    """Class to control the tracking camera pickoff. NOT FOR GENERAL USE.

    Note: this class interacts directly with the TCP. If you want to use the 
    TCP, please use the shared memory structure or the higher level library.
    """

    def __init__(self, configPath:str, move:bool=False, NPSport:int=None):
        """Constructor for the TCP control code.

        Inputs:
            configPath = the location of the TCP config file
            move = whether this stage can move (including reference) in 
                initialization or not
            NPSport = which port this device is connected to on the NPS
        """
        
        #register handles keyboard interupts and exceptions
        #signal handles tmux kill
        info("Registering cleanup.")
        register(self.close)
        signal(SIGHUP, self.close)

        self.config=ConfigParser()
        info("Reading config file.")
        #we store the config path so that we can update the file if necessary
        self.config_path=configPath
        _=self.config.read(configPath+"TCP.ini")
        info(_[0]+" read.")

        #shm_d is state shared memory.
        d_shm_name=self.config.get("Shm_path", "Shm_D")
        info("Reading state shared memory.")

        self.str_d={}
        for name in self.config.options("Shm_D_Content"):
            self.str_d[name]=np.int(self.config.getfloat("Shm_D_Content", name))

        self.Shm_D=shm(d_shm_name)

        try:
            info("Checking whether there is already an active control script.")
            status=self.Shm_D.get_data()[self.str_d["status"]]

            if status == 1 or status == 0:
                info("Active control script exists. Raising exception.")
                msg="State shared memory status {}.".format(status)
                raise AlreadyAlive(msg)
        except AttributeError:
            info("No state shared memory file. Creating file.")
            data=np.zeros([np.int(self.config.getfloat("Shm_dim", "Shm_D_dim")), 1])
            for name in self.config.options("Shm_D_Content"):
                data[self.str_d[name], 0]=self.config.getfloat("Shm_D_Init", name)

            self.Shm_D = shm(d_shm_name, data= data)
            info("State shared memory file created.")

        info("No duplicate control scripts, continuing with initialization.")
        #Store for any future turn ons whether this device can move
        self.move=move

        #shm_p is command shared memory
        self.p_shm_name=self.config.get("Shm_path", "Shm_P")
        info("Initializing command shared memory from config file.")
        data=np.zeros([np.int(self.config.getfloat("Shm_dim", "Shm_P_dim")), 1])
        self.str_p={}
        for name in self.config.options("Shm_P_Content"):
            self.str_p[name]=np.int(self.config.getfloat("Shm_P_Content", name))
            data[self.str_p[name],0]=self.config.getfloat("Shm_P_Init", name)

        self.Shm_P=shm(self.p_shm_name, data=data)
        info("Command shared memory successfully created.")

        info("Initializing NPS.")
        self.NPS=NPS()
        self.NPS.port=NPSport

        info("Checking if TCP is on")
        self.pidevice=GCSDevice()
        if self.NPS.getStatusAll()[self.NPS.port] == True:
            info("Connecting to TCP")
            self.connect_device()

        info("Updating shared memory.")
        self.update()

        info("Beginning loop.")

        #set semaphore flag
        self.loop()

    def loop(self):
        """Repeated behavior of the TCP control script"""

        self.display()

        while True:

            #check=True makes the shared memory reader wait for a new write.
            data=self.Shm_P.get_data(check=True)
            info("Command shared memory updated.")

            req_status=data[self.str_p["status"]].item()
            if req_status == -1:
                info("Killing control script")
                self.close()
            elif req_status == 0:
                info("Turning off device.")
                self.device_off()
            elif req_status == 2:
                info("Referencing device.")
                err=self.ref()
                
                info("Changing command shared memory status and svo to 1") 
                data[self.str_p["status"]] = 1
                data[self.str_p["svos"]] = 1 
                self.Shm_P.set_data(data)
                self.update(error=err)
            else:
                info("On status requested. Checking connection to TTM.")
                dataD=self.Shm_D.get_data()
                dev_status=dataD[self.str_d["status"]].item()
                error=dataD[self.str_d["error"]]
                if dev_status == 0 and req_status == 1:
                    info("Turning on device.")
                    self.device_on()
                    data=self.Shm_P.get_data()
                if dev_status == 1 or req_status == 1:
                    #peform any requested move
                    self.svo_check(data)
                    error=self.move_check(data)

                self.update(error=error)
            
            info("waiting on commands.")
            self.display()

    def ref(self) -> int:
        """References all axes
        
        Outputs:
            int = 0 if successful, 3 if not
        """

        info("Waiting for axis to finish moving.")
        if self.pidevice.IsMoving()["1"]:
            self.waitOnMove()

        if self.pidevice.qSVO("1") == 0:
            info("Turning on servo.")
            self.pidevice.SVO({"1":1})

        info("Referencing device.")
        self.pidevice.FRF("1")

        info("Waiting for axes to finish homing.")
        err=self.waitOnMove()
        info("Done referencing.")
        return err

    def svo_check(self, data:list):
        """Sets servo status to what is in the command shared memory.

        Inputs:
            data = the contents of command shared memory
        """

        info("Checking if servo value should be changed.")
        if self.pidevice.qSVO()["1"] != data[self.str_p["svos"]]:
            info("Setting servo value")
            self.pidevice.SVO({"1":int(data[self.str_p["svos"]])})

    def move_check(self, data:list) -> int:
        """Moves the TCP
        
        Only moves if the current position is different than the one requested.
        
        Inputs:
            data = the contents of the command shared memory
        Outputs:
            int = the error message (see config file)
        """
        
        info("Checking whether device is referenced.")
        if not self.pidevice.qFRF()["1"] or not self.pidevice.qSVO()["1"]:
            info("Device not referenced.")
            return 2 

        info("Checking whether move is needed.")

        curpos=self.pidevice.qPOS()["1"]+26
        target=data[self.str_p["pos"]].item()
        info("Current position: {} target: {}".format(curpos, target))
        if target < self.limits["min"] or target > self.limits["max"]:
            info("Movements requested outside of motion range.")
            return 1
        elif curpos != target:
            info("Moving device to {}.".format(target))
            self.pidevice.MOV("1", target-26)

        info("Waiting for movement to finish")
        return self.waitOnMove()

    def waitOnMove(self, timeout:float=60, slp:float=.025) -> int:
        """Blocks progress until device is done moving
        
        If movement is not completed within <timeout>seconds, stops movement
        Inputs:
            timeout = how long before a move timeout is thrown (in seconds)
            slp = how long to sleep before checking if move is complete (in seconds)
        Outputs:
            int = 3 if timed out, otherwise 0
        """

        info("Waiting for device to finish moving. Timeout set at {}s.".format(timeout))
        for _ in [x*slp for x in range(0, int(timeout/slp))]:
            if not self.pidevice.IsMoving()["1"]:
                break
            sleep(slp)

        if self.pidevice.IsMoving()["1"]:
            info("Movement timeout")
            self.pidevice.HLT()
            return 3

        return 0

    def update(self, error=0):
        """Updates the state shared memory

        Inputs:
            error = the error to put into memory
        """
        
        info("Getting old state shared memory.")
        old=self.Shm_D.get_data()
       
        info("Checking whether device is on.")
        dev_status=self.NPS.getStatusAll()[self.NPS.port]
        if dev_status == False or self.pidevice is None:
            info("Device is off, setting state shared memory.")
            old[self.str_d["status"]]=0
            old[self.str_d["error"]]=error
            old[self.str_d["cur_t"]]=time()
            self.Shm_D.set_data(old)
            return
        
        if error == 2 or not self.pidevice.qFRF()["1"]:
            info("Unreferenced error passed. Updating state shared memory.")
            old[self.str_d["status"]]=1
            old[self.str_d["error"]]=2
            old[self.str_d["cur_t"]]=time()
            self.Shm_D.set_data(old)
            return
            
        info("Device is on and referenced. Getting update information.")
        curpos=self.pidevice.qPOS()["1"]+26
        tim=time()
        
        #update if necessary
        info("Updating state shared memory")

        data={"pos" : curpos, "cur_t" : tim, "status" : 1, "error" : error}
        for name in self.str_d:
            info("{}: {}".format(name, data[name]))
            old[self.str_d[name]]=data[name]
                
        self.Shm_D.set_data(old)
        info("Shared memory updated.")

    def connect_device(self):
        """Connects the TTM. If device is already connected or off, does nothing.
        
        Reloads limits from config file and, if self.move==True, references.
        If the limits in the config file are outside the software limits,
            the config file will be rewritten
        """
        
        if self.NPS.getStatusAll()[self.NPS.port] and not self.pidevice.IsConnected():
            info("Connecting TCP PI controller.")
            self.pidevice.ConnectRS232(comport="/dev/ttyUSB0", baudrate=9600)
            #self.pidevice.ConnectTCPIP(ipaddress = self.config.get("Communication", "IP_Address"))
            info("TCP connected.")
            
            info("Extracting limits from config file.")
            self.limits={}
            for name in self.config.options("TCP_Limits"):
                self.limits[name]=self.config.getfloat("TCP_Limits", name)
            info("Limits: {}".format(self.limits))
            
            info("Checking that config limits are within software limits.")
            change=False
            softmin=self.pidevice.qTMN()["1"]+26
            softmax=self.pidevice.qTMX()["1"]+26
            if self.limits["min"] < softmin: 
                self.limits["min"] = softmin
                self.config.set("TCP_Limits", "min", str(self.limits["min"]))
                change=True
            if self.limits["max"] > softmax:
                self.limits["max"] = softmax
                self.config.set("TCP_Limits", "max", str(self.limits["max"]))
                change=True
            if change:
                with open(self.config_path+"TCP.ini", "w") as file:
                    info("Software limits: [{}, {}]".format(self.limits["max"], self.limits["min"]))
                    info("Changing limits in config file.")
                    self.config.write(file)
            
            data=self.Shm_P.get_data()
            
            info("Setting servo to command shared memory value.")
            self.pidevice.SVO({"1" : int(data[self.str_p["svos"]])})

            if self.move:
                info("Referencing device.")
                err=self.ref()
                _=self.move_check(self.Shm_P.get_data())
                if _!=0: err=_
                self.update(error=err)
            else:
                info("Movement not enabled.")
                if self.pidevice.qFRF("1"):
                    pos=self.pidevice.qPOS()["1"]+26
                    data[self.str_p["pos"]]=pos
                    self.Shm_P.set_data(data)
                    self.Shm_P.get_data(check=True)
                else:
                    info("Movement is not enabled and device is unreferenced.")

        info("TCP connected.")
        
    def device_off(self):
        """Turns off the TCP using the NPS"""
        
        info("Checking if TCP is connected.")
        if self.pidevice is not None and self.pidevice.IsConnected():
            info("Turning off servos.")
            self.pidevice.SVO("1", 0)
            info("Closing connecting to TCP")
            self.pidevice.CloseConnection()
            
        info("Checking if TCP is off")
        if self.NPS.getStatusAll()[self.NPS.port]:
            info("Turning TCP off")
            self.NPS.turnOff(self.NPS.port)
            
        self.update()
        
    def device_on(self):
        """Turns on the TCP using the NPS"""
        
        info("Checking if TCP is on.")
        if not self.NPS.getStatusAll()[self.NPS.port]:
            info("Turning on TCP.")
            self.NPS.turnOn(self.NPS.port)
            
        info("Opening connection to TCP.")
        self.connect_device()
        
    def close(self):
        """A cleanup method.
        
        Closes all communication with the TTM, deletes command shared memory,
        and closes tmux session.
        """ 
        
        info("Checking whether this instance is alive.")
        try:
            self.Shm_P
            info("Command shared memory initialized, instance alive")
            info("Continuing with cleanup.")
        except AttributeError:
            info("No command shared memory initialized. Doing nothing.")
            return

        info("Deleting command shared memory file.")
        try:
            os.remove(self.p_shm_name)
        except FileNotFoundError:
            info("No command shared memory found.")

        info("Updating state shared memory file.")
        try:
            data=self.Shm_D.get_data()
            stat=data[self.str_d["status"]].item()
            if stat in [1, 0]:
                data[self.str_d["status"]]=stat-2
                self.Shm_D.set_data(data)
        except AttributeError:
            info("No state shared memory.")


        info("Checking if TTM is connected.")
        try:
            if self.pidevice.IsConnected():
                info("Closing connection to TTM.")
                self.pidevice.CloseConnection()
        except OSError:
            info("PIPython notp loaded properly.")

        info("Closing tmux session.")
        bash(self.config.get("Environment", "end_command").split())

    def display(self):
        """A method to display shared memory contents in stdout."""

        info("Drawing status window.")

        dataD=self.Shm_D.get_data()
        dataP=self.Shm_P.get_data()

        #Note, the script off statuses in state shm will never be refelected here.
        dpos=dataD[self.str_d["pos"]].item()

        ppos=dataP[self.str_p["pos"]].item()

        svoStatus={1: "on", 0: "off"}[dataP[self.str_p["svos"]].item()]
        
        dstatus={1:"Script: on | Device: on", 0:"Script: on | Device: off"}
        dstatus=dstatus[dataD[self.str_d["status"]].item()]

        pstatus={1:"Device on", 0:"Device off", 2:"Reference"}
        pstatus=pstatus[dataP[self.str_p["status"]].item()]

        derror={0:"No error", 1:"Move requested beyond limits",\
                2:"Device unreferenced", 3:"Movement timed out"}
        derror=derror[dataD[self.str_d["error"]].item()]

        curtime=ctime(dataD[self.str_d["cur_t"]].item())

        os.system("clear")
        print(u"\u250F""{}"u"\u2513".format(u"\u2501"*77))
        print(u"\u2503""{:^77}"u"\u2503".format("TCP Controller"))
        print(u"\u2523""{:<38}"u"\u2533""{:<38}"u"\u252B".format(u"\u2501"*38, u"\u2501"*38))
        print(u"\u2503"" {:<37}"u"\u2503"" {:<37}"u"\u2503".format("Device state:","Requests:"))
        print(u"\u2503"" {:<37}"u"\u2503"" {:<37}"u"\u2503".format("",""))
        print(u"\u2503"" {:<37}"u"\u2503"" {:<37}"u"\u2503".format("Position:","Position:"))
        print(u"\u2503"" {:<37}"u"\u2503"" {:<37}"u"\u2503".format(dpos,ppos))
        print(u"\u2503"" {:<37}"u"\u2503"" {:<37}"u"\u2503".format("",""))
        print(u"\u2503"" {:<37}"u"\u2503"" {:<37}"u"\u2503".format("Time of last update:","Servo status:"))
        print(u"\u2503"" {:<37}"u"\u2503"" {:<37}"u"\u2503".format(curtime,svoStatus))
        print(u"\u2503"" {:<37}"u"\u2503"" {:<37}"u"\u2503".format("",""))
        print(u"\u2503"" {:<37}"u"\u2503"" {:<37}"u"\u2503".format("Status:","Status:"))
        print(u"\u2503"" {:<37}"u"\u2503"" {:<37}"u"\u2503".format(dstatus, pstatus))
        print(u"\u2503"" {:<37}"u"\u2503"" {:<37}"u"\u2503".format("",""))
        print(u"\u2503"" {:<37}"u"\u2503"" {:<37}"u"\u2503".format("Error message:",""))
        print(u"\u2503"" {:<37}"u"\u2503"" {:<37}"u"\u2503".format(derror,""))
        print(u"\u2517"+u"\u2501"*38+u"\u253B"+u"\u2501"*38+u"\u251B")


if __name__ == "__main__":

    config=ConfigParser()
    config.read(config_path+"TCP.ini")

    #find NPS port number
    nps=NPS()
    devices=nps.devices
    try:
        NPS_port=devices.index("FIU TCP")
    except ValueError as ouch:
        print("Could not find TCP port on NPS.")
        raise ouch

    log_path=config.get("Communication", "log_path")
    debug_format="%(filename)s.%(funcName)s@%(asctime)s - %(levelname)s: %(message)s"

    debugHelp="Sets the program to a debug (verbose) mode. Default log location is {logDef}. Can also use this tag to specify a different log location."

    parser=ArgumentParser(description="Control script for the TTM.")
    parser.add_argument("-m", "--move", action="store_true", help="Lets the TCP move to the position specified in the config file.")
    parser.add_argument("-d", "--debug", default=-1, nargs="?", help=debugHelp.format(logDef=log_path))
    parser.add_argument("-d!", "--deepDebug", default=-1, nargs="?", help=debugHelp.format(logDef=log_path))
    
    args=parser.parse_args()

    if args.debug != -1:
        if args.debug == None:
            basicConfig(format=debug_format, datefmt="%H:%M:%S", filename=log_path, level=INFO, filemode="w")
        else:
            basicConfig(format=debug_format, datefmt="%H:%M:%S", filename=args.debug, level=INFO, filemode="w")
    if args.deepDebug != -1:
        if args.deepDebug == None: 
            basicConfig(format=debug_format, datefmt="%H:%M:%S", filename=log_path, level=DEBUG, filemode="w")
        else:
            basicConfig(format=debug_format, datefmt="%H:%M:%S", filename=args.debug, level=DEBUG, filemode="w")


    TCP(configPath=config_path, move=args.move, NPSport=NPS_port)
