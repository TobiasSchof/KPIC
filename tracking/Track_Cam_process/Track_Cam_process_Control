#!/usr/bin/env kpython3

# standard library
from configparser import ConfigParser
from atexit import register, unregister
from time import time, ctime, sleep
from signal import signal, SIGHUP, SIGTERM
from subprocess import Popen
import sys, os

# installs
import numpy as np
from astropy.io import fits

# nfiuserver libraries
from KPIC_shmlib import Shm
from Track_Cam_cmds import TC_cmds

""""

THIS IS A CONTROL SCRIPT FOR IMAGE PROCESSING FOR THE FIBER
INJECTION UNIT's TRACKING CAMERA AND NOT FOR USE BY USER

See Track_Cam_process for the user-end library

"""

# variable to track whether this script should be alive
alive = True

class AlreadyAlive(Exception):
    """An exception to be thrown if control code is initialized twice"""
    pass

def main():
    """Main method to process images"""

    # start an average
    avg, raw = roll_avg(None, [])

    while alive:

        err = 0

        # check if processing is off
        if not Set.get_data()[0] & 1:
            # if it is, wait for Set to be updated
            Set.get_data(True)
            continue

        # get a new avg
        avg, raw = roll_avg(avg, raw)

        # copy avg to new array to modify
        proc = avg.copy()

        # try to subtract bias
        if Set.get_data()[0] & 2:
            try: proc = proc - Bias.get_data()
            except: err = 1
        # try to subtract background
        if Set.get_data()[0] & 4:
            try: proc = proc - Bkgrd.get_data()
            except: err = 2
        # try to subtract reference image
        if Set.get_data()[0] & 8:
            try: proc = proc - Ref.get_data()
            except: err = 3

        # apply any scale desired
        scale = Scale.get_data()[0]
        if scale == 1:
            # create a mask to only log positive values
            mask = np.ma.masked_greater(proc, 0)
            proc = np.log10(proc, where=proc.mask)
        elif scale == 2:
            # create a mask to only work on non-negative values
            mask = np.ma.masked_greater_equal(proc, 0)
            proc = np.sqrt(proc, where=proc.mask)
        
        rng = [None, None]
        # get commanded mins and maxes
        min_u, min_val, max_u, max_val = *PRng.get_data()

        # get min value
        if min_u: rng[0] = min_val 
        else: rng[0] = proc.min()

        # get max value
        if max_u: rng[1] = max_val
        else: rng[1] = proc.max()

        # clip if using any custom values
        if max_u or min_u: proc.clip(min if min_u else None, max if max_u else None)

        # save frame's min and max values
        DRng.set_data(rng, DRng.npdtype)

        # set error if there was one
        if err != 0 or err != Error.get_data():
            Error.set_data(np.array([err], Error.npdtype))

        Proc.set_data(proc)

def roll_avg(avg:np.array, raw:list):
    """A method that refreshes the average

    Pulls a new image, appends it to raw, removes the first element in raw,
        then checks to make sure that raw is long enough

    If the new frame pulled is a of a different size, a whole new avg will be created

    Args:
        avg = the current rolling average
            (if None, a new one will be created from scratch)
        raw = a list of raw frames corresponding to the given average
    Returns:
        (np.array, [np.array]) = the averaged frames, a list of raw frames
    """

    old_frames = []
    old_len = len(raw)
    # pop at least one frame
    if len(raw) >= 1:
        old_frames = [raw.pop(0) for _ in range(0, len(raw) - Avg_cnt.get_data()[0] + 1)]

    # fill out avg buffer
    new_frames = [Img.get_data(True, reform=True) for _ in range(0, Avg_cnt.get_data()[0] - len(raw))]
    raw.append(new_frames)

    # make sure that all our frames are the same size
    while(raw[0].shape != raw[-1].shape):
        old_frames.append(raw.pop[0])
        new_frames.append(Img.get_data(True, reform=True))
        raw.append(new_frames[-1])

    # case 1: we have all new frames, throw out avg and remake
    if len(new_frames >= raw):
        return np.mean(raw, 0), raw
    # case 2: the more likely one, we can use avg to cut down the calculations needed
    else:
        avg = (avg*old_len - np.sum(old_frames, 0) + np.sum(new_frames, 0)) / len(raw)
        return avg, raw

def close(*args, **kwargs):
    """Method to perform a clean close"""

    alive = False

    # try to wake up main if it's waiting for processing to start
    try: Set.sem.release()
    except: pass

    # delete Set shm to indicate that control script is off
    try: os.remove(Set.fname)
    except Exception as ouch: print("Exception on close {}".format(ouch))

# get RELDIR location which has all kroot made files
RELDIR = os.environ.get("RELDIR")
if RELDIR[-1] == "/": RELDIR = RELDIR[:-1]

# read config file in the data subdirectory of RELDIR
config = ConfigParser()
config.read(RELDIR+"/data/Track_Cam_process.ini")

# make folder for shared memories if it doesn't exist
if not os.path.isdir("/tmp/Track_Cam"): os.mkdir("/tmp/Track_Cam")

# create a dictionary to translate strings into numpy data types
type_ = {"int8":np.int8, "int16":np.int16, "int32":np.int32, "int64":np.int64,
    "uint8":np.uint8, "uint16":np.uint16, "uint32":np.uint32,
    "uint64":np.uint64, "intp":np.intp, "uintp":np.uintp, "float16":np.float16,
    "float32":np.float32, "float64":np.float64, "complex64":np.complex64,
    "complex128":np.complex128}

# check if there's another control script running by checking
#   for the existence of some shms that get deleted when control
#   script ends

Set = config.get("Shm Info", "Set").split(",")
if os.path.isfile(Set[0]):
    print("Active control script exists.")
    msg = "Set shm exists, meaning another control script is running."
    raise AlreadyAlive(msg)
else:
    Set = Shm(Set[0], data=np.array([2], dtype=type_[Set[1]]),
        mmap = (Set[2] == "1"))

Scale   = config.get("Shm Info", "Scale").split(",")
Avg_cnt = config.get("Shm Info", "Avg").split(",")
Ref     = config.get("Shm Info", "Ref").split(",")
Proc    = config.get("Shm Info", "Proc").split(",")
Bkgrd   = config.get("Shm Info", "Bkgrd").split(",")
Bias    = config.get("Shm Info", "Bias").split(",")
Error   = config.get("Shm Info", "Error").split(",")
DRng    = config.get("Shm Info", "DRng").split(",")
PRng    = config.get("Shm Info", "PRng").split(",")

if os.path.isfile(Scale[0]): Scale = Shm(Scale[0])
else: Scale = Shm(Scale[0], data = np.array([0], dtype = type_[Scale[1]]),
        mmap = (Scale[2] == "1"))

if os.path.isfile(Avg_cnt[0]): Avg_cnt = Shm(Avg_cnt[0])
else: Avg_cnt = Shm(Avg_cnt[0], data = np.array([5], dtype = type_[Avg_cnt[1]]),
        mmap = (Avg_cnt[2] == "1"))

if os.path.isfile(Proc[0]): Proc = Shm(Proc[0])
else: Proc = Shm(Proc[0], data = np.zeros([640, 512], dtype = type_[Proc[1]]),
        mmap = (Proc[2] == "1"))

if os.path.isfile(Ref[0]): Ref = Shm(Ref[0])
else: Ref = Shm(Ref[0], data = np.zeros([640, 512], dtype = type_[Ref[1]]),
        mmap = (Ref[2] == "1"))

if os.path.isfile(Bkgrd[0]): Bkgrd = Shm(Bkgrd[0])
else: Bkgrd = Shm(Bkgrd[0], data = np.zeros([640, 512], dtype = type_[Bkgrd[1]]),
        mmap = (Bkgrd[2] == "1"))

if os.path.isfile(Bias[0]): Bias = Shm(Bias[0])
else: Bias = Shm(Bias[0], data = np.zeros([640, 512], dtype = type_[Bias[1]]),
        mmap = (Bias[2] == "1"))

if os.path.isfile(Error[0]): Error = Shm(Error[0])
else: Error = Shm(Error[0], data = np.zeros([640, 512], dtype = type_[Error[1]]),
        mmap = (Error[2] == "1"))

if os.path.isfile(DRng[0]): DRng = Shm(DRng[0])
else: DRng = Shm(DRng[0], data = np.zeros([640, 512], dtype = type_[DRng[1]]),
        mmap = (DRng[2] == "1"))

if os.path.isfile(PRng[0]): PRng = Shm(PRng[0])
else: PRng = Shm(PRng[0], data = np.zeros([640, 512], dtype = type_[PRng[1]]),
        mmap = (PRng[2] == "1"))

# connect to raw img shm
img_conf = ConfigParser()
img_conf.read(RELDIR+"/data/Track_Cam.ini")

Img = img_conf.get("Shm Info", "IMG").split(",")
Img = Shm(Img[0], sem=True)

# location of bias frames
DARKDIR = img_conf.get("Data", "bias_dir")

# register cleanup after shm initialization so that they
#   get cleaned up before being deleted
register(close)
signal(SIGHUP, signal_handler)
signal(SIGTERM, signal_handler)

# instantiate TC_cmds
tc = TC_cmds()

# start main method
main()